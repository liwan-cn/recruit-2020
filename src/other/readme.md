# 其他

以下题目来自本人或舍友笔面试, 还有部分来自网络上的笔面经, 是一些比较经典或者新奇的题目, 部分题目与舍友一块讨论得出答案. 

## 1. 最多不相交

**今日头条面试** 

1. `pair(s, e)`, 表示从 `s` 到 `e`, 有一条连线
2. 所有的 `s` 从小到大排序在左侧排成一列
3. 所有的 `e` 从小到大排序在右侧排成一列
4. 最少删除多少 `pair` 对, 使所有的线不相交  
 
***抽象问题: 以 `s`排序, 求 `e` 的最长递增子序列***

## 2. 加油的最少次数

**腾讯微信面试**

1. 汽车油箱无限大
2. 每个加油站提供的油量有限
3. 汽车从加油站 `1` 出发, 到加油站 `n` 结束
4. 求最少加油次数

***贪心算法: 每次开到没油, 从前边经过的未加油的加油站中油量最大的加油, 次数加 1***

## 3. 矩阵乘法优化

**今日头条面试**  

`C = A * B`  

不是优化时间复杂度, 而是从计算机组成的角度考虑优化  
利用程序的局部性原理, 把 `B` 矩阵转置, 提高 `cache` 命中率
或者是把3层循环的内2层交换顺序

## 4. 百度搜索的搜索热点和相关搜索

**百度面试**  

搜索热点: 统计 `query` 日志, 统计次数, 计算绝对量和相对增量   
相关搜索: 用户搜索后继词

## 5. 逆序对的个数

**今日头条面试**  
 
剑指offer, 归并排序

## 6. 称重量

**百度面试**  

`100` 瓶药, 每一瓶里有 `100` 粒药  
 其中 `99` 瓶中每一粒药都是 `1g`, 剩下 `1` 瓶中的每一粒药是 `0.9g`   
 给一个秤, 只秤一次, 得到是哪一瓶里的药是 `0.9g`   
 
 ***药瓶编号 `1 - 100`, 第 `i` 瓶里取 `i` 粒药, 称重为 `Xg`***   
 ***`result = ((1 + 100) * 100 / 2 - X) / 0.1`***
 
## 7. 二叉树镜像

**百度面试**

给定一个二叉树得到它的镜像二叉树, 要求使用非递归   

***队列或者栈***

## 8. 同构二叉树

**京东面试**

两棵二叉树, 判断其中一棵二叉树能不能通过另外一棵二叉树的有限次左右节点的交换得到

**参考代码**
```
public boolean isSame(TreeNode t1, TreeNode t2) {
    if (t1 == null || t2 == null) {
        return (t1 == null && t2 == null)
    }
    if (t1.val != t2.val) return false;
    return (isSame(t1.left, t2.left) && isSame(t1.right, t2.right)) 
            || (isSame(t1.left, t2.right) && isSame(t1.right, t2.left)) 
}
```
**时间复杂度**
h=log2n为树的高度O(1) = 1, O(h) = 4*O(h-1) = 4^h = 4^(log2n) = n^2

## 9. 查找峰值

**拼夕夕面试**

峰值元素是指其值大于左右相邻值的元素, 给定数组 `nums`，其中 `nums[i] ≠ nums[i+1]`, 返回峰值元素索引, 包含多个峰值时, 返回任何一个即可.
假设 `nums[-1] = nums[n] = -∞`

***二分查找, leetcode 162***

## 10. 恢复原始排列

一副从 `1 - n` 的牌, 每次从牌堆顶取一张放桌子上, 再取一张放牌堆底, 直到没牌，最后桌子上的牌是从 `1 - n` 有序, 求原始牌堆顺序.   

#### 解题方法

1. ***对数组 `indexBefore = [1, 2, 3, ..., n]` 进行同样的操作得到数组 `indexAfter`***
2. ***由题意知 `numAfter = [1, 2, 3, ..., n]`, 这样就知道了转换前 `index` 与 `num` 的对应关系***
3. ***根据对应关系还原 `numBefore`, 即把对应关系按照 `index` 从 `1 - n` 排序***

#### 解题思路

1. ***可以理解为把原始的数组里的每一个元素当成一个 `pair<index, num>`***   
2. ***对 `numBefore` 和 `indexBefore` 相应的相同的操作同时, 其对应关系保持不变***   
3. ***现在已知 `numAfter` 的排列, `indexBefore` 的排列***   
4. ***对 `indexBefore` 进行相同的操作, 得到`indexAfter`, 从而得到了 `pair<index, num>`, 即 `numBefore` 中 `index` 与 `num` 的对应关系, 这就可以还原 `numBefore` 了***

#### 例子
`n = 5`

1. 对 `indexBefore = [1, 2, 3, 4, 5]` 进行题目中的操作得到 `indexAfter = [1, 3, 5, 4, 2]`   
2. `numBefore = [1, 2, 3, 4, 5]`, 得到 `index` 与 `num` 的映射关系 `{1: 1, 3: 2, 5: 3, 4: 4, 2: 5}`, 说明 `numBefore` 中 `1` 的位置是 `1`, `3` 的位置是 `2`, ...   
3. 还原 `numBefore = [1, 5, 2, 4, 3]`

#### 这道题还可以继续扩展：

1. 变换规则更复杂使得无法逆向模拟还原原数组
2. 最终得到的序列可以扩展为任意序列


## 11. n个[0,n)的数，求每个数的出现次数（不能开辟额外空间）
1. 给一个索引下的数不管加上多少个n，那么这个数对n取余的话，我们就能知道这个数原来是多少；
2. 如果一个数出现t次，我们就在对应索引位置下的数加上t*n，那么每个数对应索引位置上的数对n取余，就是这个数出现的次数。

## 12. 最大频率栈
实现 FreqStack，模拟类似栈的数据结构的操作的一个类。      
FreqStack 有两个函数：   
    *  push(int x)，将整数 x 推入栈中。   
    * pop()，它移除并返回栈中出现最频繁的元素。如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。   
    
◼ 示例：   
push [5,7,5,7,4,5]   
pop() -> 返回 5，因为 5 是出现频率最高的。栈变成[5,7,5,7,4]。   
pop() -> 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。 栈变成 [5,7,5,4]。   
pop() -> 返回 5 。 栈变成 [5,7,4]。   
pop() -> 返回 4 。 栈变成 [5,7]。


#### **参考答案**：

令 freq 作为 x 的出现次数的映射 Map。

此外 maxfreq，即栈中任意元素的当前最大频率，因为我们必须弹出频率最高的元素。

当前主要的问题就变成了：在具有相同的（最大）频率的元素中，怎么判断那个元素是最新的？我们可以使用栈来查询这一信息：靠近栈顶的元素总是相对更新一些。

为此，我们令 group 作为从频率到具有该频率的元素的映射。到目前，我们已经实现了 FreqStack 的所有必要的组件。

算法：

实际上，作为实现层面上的一点细节，如果 x 的频率为 f，那么我们将获取在所有 group[i] (i <= f) 中的 x,而不仅仅是栈顶的那个。这是因为每个 group[i] 都会存储与第 i 个 x 副本相关的信息。

最后，我们仅仅需要如上所述维持 freq，group，以及 maxfreq。

**参考代码**：
```
class FreqStack {
    Map<Integer, Integer> freq;
    Map<Integer, Stack<Integer>> group;
    int maxfreq;

    public FreqStack() {
        freq = new HashMap();
        group = new HashMap();
        maxfreq = 0;
    }
    
    public void push(int x) {
        int f = freq.getOrDefault(x, 0) + 1;
        freq.put(x, f);
        if (f > maxfreq) maxfreq = f;
        group.computeIfAbsent(f, z-> new Stack()).push(x);
    }
    
    public int pop() {
        int x = group.get(maxfreq).pop();
        freq.put(x, freq.get(x) - 1);
        if (group.get(maxfreq).size() == 0)
        maxfreq--;
        return x;
    }
}
```


