# 其他

以下题目来自本人或舍友笔面试, 还有部分来自网络上的笔面经, 是一些比较经典或者新奇的题目, 部分题目与舍友一块讨论得出答案. 

## 1. 最多不相交

**今日头条面试** 

1. `pair(s, e)`, 表示从 `s` 到 `e`, 有一条连线
2. 所有的 `s` 从小到大排序在左侧排成一列
3. 所有的 `e` 从小到大排序在右侧排成一列
4. 最少删除多少 `pair` 对, 使所有的线不相交  
 
***抽象问题: 以 `s`排序, 求 `e` 的最长递增子序列***

## 2. 加油的最少次数

**腾讯微信面试**

1. 汽车油箱无限大
2. 每个加油站提供的油量有限
3. 汽车从加油站 `1` 出发, 到加油站 `n` 结束
4. 求最少加油次数

***贪心算法: 每次开到没油, 从前边经过的未加油的加油站中油量最大的加油, 次数加 1***

## 3. 矩阵乘法优化

**今日头条面试**  

`C = A * B`  

不是优化时间复杂度, 而是从计算机组成的角度考虑优化  
利用程序的局部性原理, 把 `B` 矩阵转置, 提高 `cache` 命中率

## 4. 百度搜索的搜索热点和相关搜索

**百度面试**  

搜索热点: 统计 `query` 日志, 统计次数, 计算绝对量和相对增量   
相关搜索: 用户搜索后继词

## 5. 逆序对的个数

**今日头条面试**  
 
剑指offer, 归并排序

## 6. 称重量

**百度面试**  

`100` 瓶药, 每一瓶里有 `100` 粒药  
 其中 `99` 瓶中每一粒药都是 `1g`, 剩下 `1` 瓶中的每一粒药是 `0.9g`   
 给一个秤, 只秤一次, 得到是哪一瓶里的药是 `0.9g`   
 
 ***药瓶编号 `1 - 100`, 第 `i` 瓶里取 `i` 粒药, 称重为 `Xg`***   
 ***`result = ((1 + 100) * 100 / 2 - X) / 0.1`***
 
## 7. 二叉树镜像

**百度面试**

给定一个二叉树得到它的镜像二叉树, 要求使用非递归   

***队列或者栈***

## 8. 查找峰值

**拼夕夕面试**

峰值元素是指其值大于左右相邻值的元素, 给定数组 `nums`，其中 `nums[i] ≠ nums[i+1]`, 返回峰值元素索引, 包含多个峰值时, 返回任何一个即可.
假设 `nums[-1] = nums[n] = -∞`

***二分查找, leetcode 162***

## 9. 恢复原始排列

一副从 `1 - n` 的牌, 每次从牌堆顶取一张放桌子上, 再取一张放牌堆底, 直到没牌，最后桌子上的牌是从 `1 - n` 有序, 求原始牌堆顺序.   

#### 解题方法

1. ***对数组 `indexBefore = [1, 2, 3, ..., n]` 进行同样的操作得到数组 `indexAfter`***
2. ***由题意知 `numAfter = [1, 2, 3, ..., n]`, 这样就知道了转换前 `index` 与 `num` 的对应关系***
3. ***根据对应关系还原 `numBefore`, 即把对应关系按照 `index` 从 `1 - n` 排序***

#### 解题思路

1. ***可以理解为把原始的数组里的每一个元素当成一个 `pair<index, num>`***   
2. ***对 `numBefore` 和 `indexBefore` 相应的相同的操作同时, 其对应关系保持不变***   
3. ***现在已知 `numAfter` 的排列, `indexBefore` 的排列***   
4. ***对 `indexBefore` 进行相同的操作, 得到`indexAfter`, 从而得到了 `pair<index, num>`, 即 `numBefore` 中 `index` 与 `num` 的对应关系, 这就可以还原 `numBefore` 了***

#### 例子
`n = 5`

1. 对 `indexBefore = [1, 2, 3, 4, 5]` 进行题目中的操作得到 `indexAfter = [1, 3, 5, 4, 2]`   
2. `numBefore = [1, 2, 3, 4, 5]`, 得到 `index` 与 `num` 的映射关系 `{1: 1, 3: 2, 5: 3, 4: 4, 2: 5}`, 说明 `numBefore` 中 `1` 的位置是 `1`, `3` 的位置是 `2`, ...   
3. 还原 `numBefore = [1, 5, 2, 4, 3]`

#### 这道题还可以继续扩展：

1. 变换规则更复杂使得无法逆向模拟还原原数组
2. 最终得到的序列可以扩展为任意序列


## 10. n个[0,n)的数，求每个数的出现次数（不能开辟额外空间）
如果我们给一个索引下的数不管加上多少个n，那么这个数对n取余的话，我们就能知道这个数原来是多少；
另一方面，如果一个数出现一次，我们就在对应索引位置下的数加上n，那么每个数对应索引位置上的数对n取商的话，就是这个数出现的次数。
这样就做到了没有开辟额外的空间。

